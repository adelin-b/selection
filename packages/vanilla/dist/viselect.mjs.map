{"version":3,"file":"viselect.mjs","sources":["../src/EventEmitter.ts","../src/utils/css.ts","../src/utils/events.ts","../src/utils/intersects.ts","../src/utils/selectAll.ts","../src/utils/constants.ts","../src/utils/frames.ts","../src/index.ts"],"sourcesContent":["\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype AnyFunction = (...args: any[]) => any;\ntype EventMap = Record<string, AnyFunction>;\n\nexport class EventTarget<Events extends EventMap> {\n    private readonly _listeners = new Map<keyof Events, Set<AnyFunction>>();\n\n    public addEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\n        const set = this._listeners.get(event) || new Set();\n        this._listeners.set(event, set);\n        set.add(cb as AnyFunction);\n        return this;\n    }\n\n    public removeEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\n        this._listeners.get(event)?.delete(cb as AnyFunction);\n        return this;\n    }\n\n    public dispatchEvent<K extends keyof Events>(event: K, ...data: Parameters<Events[K]>): unknown {\n        let ok = true;\n        for (const cb of (this._listeners.get(event) || [])) {\n            ok = (cb(...data) !== false) && ok;\n        }\n\n        return ok;\n    }\n\n    public unbindAllListeners(): void {\n        this._listeners.clear();\n    }\n\n    // Let's also support on, off and emit like node\n    /* eslint-disable no-invalid-this */\n    public on = this.addEventListener;\n    public off = this.removeEventListener;\n    public emit = this.dispatchEvent;\n}\n","const unitify = (val: string | number, unit = 'px'): string => {\n    return typeof val === 'number' ? val + unit : val;\n};\n\n/**\n * Add css to a DOM-Element or returns the current\n * value of a property.\n *\n * @param el The Element.\n * @param attr The attribute or an object which holds css key-properties.\n * @param val The value for a single attribute.\n * @returns {*}\n */\nexport function css(\n    {style}: HTMLElement,\n    attr: Partial<Record<keyof CSSStyleDeclaration, string | number>> | string,\n    val?: string | number\n): void {\n    if (typeof attr === 'object') {\n\n        for (const [key, value] of Object.entries(attr)) {\n            value !== undefined && (style[key as any] = unitify(value));\n        }\n\n    } else if (val !== undefined) {\n        style[attr as any] = unitify(val);\n    }\n}\n\n\n","/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype Method = 'addEventListener' | 'removeEventListener';\ntype AnyFunction = (...arg: any) => any;\n\nexport type EventBindingArgs = [\n        EventTarget | EventTarget[],\n        string | string[],\n    AnyFunction,\n    Record<string, unknown>?\n];\n\ninterface EventBinding {\n    (\n        elements: EventTarget | EventTarget[],\n        events: string | string[],\n        fn: AnyFunction,\n        options?: Record<string, unknown>\n    ): EventBindingArgs;\n}\n\n/* eslint-disable prefer-rest-params */\nfunction eventListener(method: Method): EventBinding {\n    return (\n        items: EventTarget | EventTarget[],\n        events: string | string[],\n        fn: AnyFunction, options = {}\n    ): EventBindingArgs => {\n\n        // Normalize array\n        if (items instanceof HTMLCollection || items instanceof NodeList) {\n            items = Array.from(items);\n        } else if (!Array.isArray(items)) {\n            items = [items];\n        }\n\n        if (!Array.isArray(events)) {\n            events = [events];\n        }\n\n        for (const el of items) {\n            for (const ev of events) {\n                el[method](ev, fn as EventListener, {capture: false, ...options});\n            }\n        }\n\n        return [items, events, fn, options];\n    };\n}\n\n/**\n * Add event(s) to element(s).\n * @param elements DOM-Elements\n * @param events Event names\n * @param fn Callback\n * @param options Optional options\n * @return Array passed arguments\n */\nexport const on = eventListener('addEventListener');\n\n/**\n * Remove event(s) from element(s).\n * @param elements DOM-Elements\n * @param events Event names\n * @param fn Callback\n * @param options Optional options\n * @return Array passed arguments\n */\nexport const off = eventListener('removeEventListener');\n\n/**\n * Simplifies a touch / mouse-event\n * @param evt\n */\nexport const simplifyEvent = (evt: any): {\n    target: HTMLElement;\n    x: number;\n    y: number;\n} => {\n    const { clientX, clientY, target } = (evt.touches && evt.touches[0] || evt);\n    return {x: clientX, y: clientY, target};\n};\n","export type Intersection = 'center' | 'cover' | 'touch'\n\n/**\n * Check if two DOM-Elements intersects each other.\n * @param a BoundingClientRect of the first element.\n * @param b BoundingClientRect of the second element.\n * @param mode Options are center, cover or touch.\n * @returns {boolean} If both elements intersects each other.\n */\nexport function intersects(a: DOMRect, b: DOMRect, mode: Intersection = 'touch'): boolean {\n    switch (mode) {\n        case 'center': {\n            const bxc = b.left + b.width / 2;\n            const byc = b.top + b.height / 2;\n\n            return bxc >= a.left &&\n                bxc <= a.right &&\n                byc >= a.top &&\n                byc <= a.bottom;\n        }\n        case 'cover': {\n            return b.left >= a.left &&\n                b.top >= a.top &&\n                b.right <= a.right &&\n                b.bottom <= a.bottom;\n        }\n        case 'touch': {\n            return a.right >= b.left &&\n                a.left <= b.right &&\n                a.bottom >= b.top &&\n                a.top <= b.bottom;\n        }\n    }\n}\n","export type SelectAllSelectors = readonly (string | Element)[] | string | Element;\n\n/**\n * Takes a selector (or array of selectors) and returns the matched nodes.\n * @param selector The selector or an Array of selectors.\n * @param doc\n * @returns {Array} Array of DOM-Nodes.\n */\nexport function selectAll(selector: SelectAllSelectors, doc: Document = document): Element[] {\n    const list = !Array.isArray(selector) ? [selector] : selector;\n    let nodes: Element[] = [];\n\n    for (let i = 0, l = list.length; i < l; i++) {\n        const item = list[i];\n\n        if (typeof item === 'string') {\n            /**\n             * We can't use the spread operator here as with large amounts of elements\n             * we'll get a \"Maximum call stack size exceeded\"-error.\n             */\n            nodes = nodes.concat(Array.from(doc.querySelectorAll(item)));\n        } else if (item instanceof Element) {\n            nodes.push(item);\n        }\n    }\n\n    return nodes;\n}\n","// Determines if the device's primary input supports touch\n// See this article: https://css-tricks.com/touch-devices-not-judged-size/\nexport const isTouchDevice = (): boolean => matchMedia('(hover: none), (pointer: coarse)').matches;\n\n// Determines if the browser is safari\nexport const isSafariBrowser = (): boolean => 'safari' in window;\n","/* eslint-disable @typescript-eslint/no-explicit-any */\ntype AnyFunction = (...args: any[]) => void;\n\nexport interface Frames<F extends AnyFunction = AnyFunction> {\n    next(...args: Parameters<F>): void;\n\n    cancel(): void;\n}\n\nexport const frames = <F extends AnyFunction>(fn: F): Frames<F> => {\n    let previousArgs: Parameters<F>;\n    let frameId = -1;\n    let lock = false;\n\n    return {\n        next(...args: Parameters<F>): void {\n            previousArgs = args;\n\n            if (!lock) {\n                lock = true;\n                frameId = requestAnimationFrame(() => {\n                    fn(...previousArgs);\n                    lock = false;\n                });\n            }\n        },\n        cancel() {\n            cancelAnimationFrame(frameId);\n            lock = false;\n        }\n    };\n};\n","import { EventTarget } from \"./EventEmitter\";\nimport type {\n  AreaLocation,\n  Coordinates,\n  ScrollEvent,\n  SelectionEvents,\n  SelectionOptions,\n  SelectionStore,\n} from \"./types\";\nimport { PartialSelectionOptions } from \"./types\";\nimport {\n  css,\n  frames,\n  Frames,\n  intersects,\n  isSafariBrowser,\n  isTouchDevice,\n  off,\n  on,\n  selectAll,\n  SelectAllSelectors,\n  simplifyEvent,\n} from \"./utils\";\n\n// Re-export types\nexport * from \"./types\";\n\n// Some var shorting for better compression and readability\nconst { abs, max, min, ceil } = Math;\n\nexport default class SelectionArea extends EventTarget<SelectionEvents> {\n  public static version = VERSION;\n\n  // Options\n  private readonly _options: SelectionOptions;\n\n  // Selection store\n  private _selection: SelectionStore = {\n    stored: [],\n    selected: [],\n    touched: [],\n    changed: {\n      added: [], // Added elements since last selection\n      removed: [], // Removed elements since last selection\n    },\n  };\n\n  // Area element and clipping element\n  private readonly _area: HTMLElement;\n  private readonly _clippingElement: HTMLElement;\n\n  // Target container (element) and boundary (cached)\n  private _targetElement?: Element;\n  private _targetRect?: DOMRect;\n  private _selectables: Element[] = [];\n  private _latestElement?: Element;\n\n  // Caches the position of the selection-area\n  private readonly _areaRect = new DOMRect();\n\n  // Dynamically constructed area rect\n  private _areaLocation: AreaLocation = { y1: 0, x2: 0, y2: 0, x1: 0 };\n\n  // If a single click is being performed.\n  // It's a single-click until the user dragged the mouse.\n  private _singleClick = true;\n  private _frame: Frames;\n\n  // Is getting set on movement.\n  private _scrollAvailable = true;\n  private _scrollingActive = false;\n  private _scrollSpeed: Coordinates = { x: 0, y: 0 };\n  private _scrollDelta: Coordinates = { x: 0, y: 0 };\n\n  constructor(opt: PartialSelectionOptions) {\n    super();\n\n    this._options = {\n      selectionAreaClass: \"selection-area\",\n      selectionContainerClass: undefined,\n      selectables: [],\n      document: window.document,\n      startAreas: [\"html\"],\n      boundaries: [\"html\"],\n      container: \"body\",\n      ...opt,\n\n      behaviour: {\n        overlap: \"invert\",\n        intersect: \"touch\",\n        ...opt.behaviour,\n        startThreshold: opt.behaviour?.startThreshold\n          ? typeof opt.behaviour.startThreshold === \"number\"\n            ? opt.behaviour.startThreshold\n            : { x: 10, y: 10, ...opt.behaviour.startThreshold }\n          : { x: 10, y: 10 },\n        scrolling: {\n          speedDivider: 10,\n          manualSpeed: 750,\n          ...opt.behaviour?.scrolling,\n          startScrollMargins: {\n            x: 0,\n            y: 0,\n            ...opt.behaviour?.scrolling?.startScrollMargins,\n          },\n        },\n      },\n\n      features: {\n        range: true,\n        touch: true,\n        ...opt.features,\n        singleTap: {\n          allow: true,\n          intersect: \"native\",\n          ...opt.features?.singleTap,\n        },\n      },\n    };\n\n    // Bind locale functions to instance\n    /* eslint-disable @typescript-eslint/no-explicit-any */\n    for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {\n      if (typeof (this as any)[key] === \"function\") {\n        (this as any)[key] = (this as any)[key].bind(this);\n      }\n    }\n\n    const { document, selectionAreaClass, selectionContainerClass } =\n      this._options;\n    this._area = document.createElement(\"div\");\n    this._clippingElement = document.createElement(\"div\");\n    this._clippingElement.appendChild(this._area);\n\n    this._area.classList.add(selectionAreaClass);\n    selectionContainerClass &&\n      this._clippingElement.classList.add(selectionContainerClass);\n\n    css(this._area, {\n      willChange: \"top, left, bottom, right, width, height\",\n      top: 0,\n      left: 0,\n      position: \"fixed\",\n    });\n\n    css(this._clippingElement, {\n      overflow: \"hidden\",\n      position: \"fixed\",\n      transform: \"translate3d(0, 0, 0)\", // https://stackoverflow.com/a/38268846\n      pointerEvents: \"none\",\n      zIndex: \"1\",\n    });\n\n    this._frame = frames((evt: MouseEvent | TouchEvent) => {\n      this._recalculateSelectionAreaRect();\n      this._updateElementSelection();\n      this._emitEvent(\"move\", evt);\n      this._redrawSelectionArea();\n    });\n\n    this.enable();\n  }\n\n  _bindStartEvents(activate = true): void {\n    const { document, features } = this._options;\n    const fn = activate ? on : off;\n\n    fn(document, \"mousedown\", this._onTapStart);\n    features.touch &&\n      fn(document, \"touchstart\", this._onTapStart, {\n        passive: false,\n      });\n  }\n\n  _onTapStart(evt: MouseEvent | TouchEvent, silent = false): void {\n    const { x, y, target } = simplifyEvent(evt);\n    const { _options } = this;\n    const { document } = this._options;\n    const targetBoundingClientRect = target.getBoundingClientRect();\n\n    // Find start-areas and boundaries\n    const startAreas = selectAll(_options.startAreas, _options.document);\n    const resolvedBoundaries = selectAll(\n      _options.boundaries,\n      _options.document\n    );\n\n    // Check in which container the user currently acts\n    this._targetElement = resolvedBoundaries.find((el) =>\n      intersects(el.getBoundingClientRect(), targetBoundingClientRect)\n    );\n\n    // Check if area starts in one of the start areas / boundaries\n    const evtPath = evt.composedPath();\n    if (\n      !this._targetElement ||\n      !startAreas.find((el) => evtPath.includes(el)) ||\n      !resolvedBoundaries.find((el) => evtPath.includes(el))\n    ) {\n      return;\n    }\n\n    if (!silent && this._emitEvent(\"beforestart\", evt) === false) {\n      return;\n    }\n\n    this._areaLocation = { x1: x, y1: y, x2: 0, y2: 0 };\n\n    // Lock scrolling in target container\n    const scrollElement = document.scrollingElement || document.body;\n    this._scrollDelta = {\n      x: scrollElement.scrollLeft,\n      y: scrollElement.scrollTop,\n    };\n\n    // To detect single-click\n    this._singleClick = true;\n    this.clearSelection(false, true);\n\n    on(document, [\"touchmove\", \"mousemove\"], this._delayedTapMove, {\n      passive: false,\n    });\n    on(document, [\"mouseup\", \"touchcancel\", \"touchend\"], this._onTapStop);\n    on(document, \"scroll\", this._onScroll);\n  }\n\n  _onSingleTap(evt: MouseEvent | TouchEvent): void {\n    const {\n      singleTap: { intersect },\n      range,\n    } = this._options.features;\n    const e = simplifyEvent(evt);\n    let target;\n\n    if (intersect === \"native\") {\n      target = e.target;\n    } else if (intersect === \"touch\") {\n      this.resolveSelectables();\n\n      const { x, y } = e;\n      target = this._selectables.find((v) => {\n        const { right, left, top, bottom } = v.getBoundingClientRect();\n        return x < right && x > left && y < bottom && y > top;\n      });\n    }\n\n    if (!target) {\n      return;\n    }\n\n    /**\n     * Resolve selectables again.\n     * If the user started in a scrollable area they will be reduced\n     * to the current area. Prevent the exclusion of these if a range-selection\n     * gets performed.\n     */\n    this.resolveSelectables();\n\n    // Traverse dom upwards to check if target is selectable\n    while (!this._selectables.includes(target)) {\n      if (!target.parentElement) {\n        return;\n      }\n\n      target = target.parentElement;\n    }\n\n    // Grab current store first in case it gets set back\n    const { stored } = this._selection;\n    this._emitEvent(\"start\", evt);\n\n    if (evt.shiftKey && stored.length && range) {\n      const reference = this._latestElement ?? stored[0];\n\n      // Resolve correct range\n      const [preceding, following] =\n        reference.compareDocumentPosition(target) & 4\n          ? [target, reference]\n          : [reference, target];\n\n      const rangeItems = [\n        ...this._selectables.filter(\n          (el) =>\n            el.compareDocumentPosition(preceding) & 4 &&\n            el.compareDocumentPosition(following) & 2\n        ),\n        preceding,\n        following,\n      ];\n\n      this.select(rangeItems);\n      this._latestElement = target;\n    } else if (\n      stored.includes(target) &&\n      (stored.length === 1 ||\n        evt.ctrlKey ||\n        stored.every((v) => this._selection.stored.includes(v)))\n    ) {\n      this.deselect(target);\n      this._latestElement = target;\n    } else {\n      this.select(target);\n      this._latestElement = target;\n    }\n\n    this._emitEvent(\"stop\", evt);\n  }\n\n  _delayedTapMove(evt: MouseEvent | TouchEvent): void {\n    const {\n      container,\n      document,\n      behaviour: { startThreshold },\n    } = this._options;\n    const { x1, y1 } = this._areaLocation; // Coordinates of first \"tap\"\n    const { x, y } = simplifyEvent(evt);\n\n    // Check pixel threshold\n    if (\n      // Single number for both coordinates\n      (typeof startThreshold === \"number\" &&\n        abs(x + y - (x1 + y1)) >= startThreshold) ||\n      // Different x and y threshold\n      (typeof startThreshold === \"object\" &&\n        abs(x - x1) >= (startThreshold as Coordinates).x) ||\n      abs(y - y1) >= (startThreshold as Coordinates).y\n    ) {\n      off(document, [\"mousemove\", \"touchmove\"], this._delayedTapMove, {\n        passive: false,\n      });\n\n      if (this._emitEvent(\"beforedrag\", evt) === false) {\n        off(document, [\"mouseup\", \"touchcancel\", \"touchend\"], this._onTapStop);\n        return;\n      }\n\n      on(document, [\"mousemove\", \"touchmove\"], this._onTapMove, {\n        passive: false,\n      });\n\n      // Make area element visible\n      css(this._area, \"display\", \"block\");\n\n      // Append selection-area to the dom\n      selectAll(container, document)[0].appendChild(this._clippingElement);\n\n      this.resolveSelectables();\n\n      // An action is recognized as single-select until the user performed a multi-selection\n      this._singleClick = false;\n\n      // Just saving the boundaries of this container for later\n      this._targetRect = this._targetElement!.getBoundingClientRect();\n\n      // Find container and check if it's scrollable\n      this._scrollAvailable =\n        this._targetElement!.scrollHeight !==\n          this._targetElement!.clientHeight ||\n        this._targetElement!.scrollWidth !== this._targetElement!.clientWidth;\n\n      if (this._scrollAvailable) {\n        // Detect mouse scrolling\n        on(document, \"wheel\", this._manualScroll, { passive: false });\n\n        /**\n         * The selection-area will also cover other element which are\n         * out of the current scrollable parent. So find all elements\n         * which are in the current scrollable element. Later these are\n         * the only selectables instead of all.\n         */\n        this._selectables = this._selectables.filter((s) =>\n          this._targetElement!.contains(s)\n        );\n      }\n\n      // Re-setup selection area and fire event\n      this._setupSelectionArea();\n      this._emitEvent(\"start\", evt);\n      this._onTapMove(evt);\n    }\n\n    this._handleMoveEvent(evt);\n  }\n\n  _setupSelectionArea(): void {\n    const { _clippingElement, _targetElement, _area } = this;\n    const tr = (this._targetRect = _targetElement!.getBoundingClientRect());\n\n    if (this._scrollAvailable) {\n      /**\n       * To clip the area, the selection area has a parent\n       * which has exact the same dimensions as the scrollable element.\n       * Now if the area exceeds these boundaries it will be cropped.\n       */\n      css(_clippingElement, {\n        top: tr.top,\n        left: tr.left,\n        width: tr.width,\n        height: tr.height,\n      });\n\n      /**\n       * The area element is relative to the clipping element,\n       * but when this is moved or transformed we need to correct\n       * the positions via a negative margin.\n       */\n      css(_area, {\n        marginTop: -tr.top,\n        marginLeft: -tr.left,\n      });\n    } else {\n      // \"Reset\" styles\n      css(_clippingElement, {\n        top: 0,\n        left: 0,\n        width: \"100%\",\n        height: \"100%\",\n      });\n\n      css(_area, {\n        marginTop: 0,\n        marginLeft: 0,\n      });\n    }\n  }\n\n  _onTapMove(evt: MouseEvent | TouchEvent): void {\n    const { x, y } = simplifyEvent(evt);\n    const { _scrollSpeed, _areaLocation, _options, _frame } = this;\n    const { speedDivider } = _options.behaviour.scrolling;\n    const _targetElement = this._targetElement as Element;\n\n    _areaLocation.x2 = x;\n    _areaLocation.y2 = y;\n\n    if (\n      this._scrollAvailable &&\n      !this._scrollingActive &&\n      (_scrollSpeed.y || _scrollSpeed.x)\n    ) {\n      // Continuous scrolling\n      this._scrollingActive = true;\n\n      const scroll = () => {\n        if (!_scrollSpeed.x && !_scrollSpeed.y) {\n          this._scrollingActive = false;\n          return;\n        }\n\n        // Reduce velocity, use ceil in both directions to scroll at least 1px per frame\n        const { scrollTop, scrollLeft } = _targetElement;\n\n        if (_scrollSpeed.y) {\n          _targetElement.scrollTop += ceil(_scrollSpeed.y / speedDivider);\n          _areaLocation.y1 -= _targetElement.scrollTop - scrollTop;\n        }\n\n        if (_scrollSpeed.x) {\n          _targetElement.scrollLeft += ceil(_scrollSpeed.x / speedDivider);\n          _areaLocation.x1 -= _targetElement.scrollLeft - scrollLeft;\n        }\n\n        /**\n         * We changed the start coordinates -> redraw the selection-area\n         * We changed the dimensions of the area element -> re-calc selected elements\n         * The selected elements array has been changed -> fire event\n         */\n        _frame.next(evt);\n\n        // Keep scrolling even if the user stops to move his pointer\n        requestAnimationFrame(scroll);\n      };\n\n      requestAnimationFrame(scroll);\n    } else {\n      /**\n       * Perform redraw only if scrolling is not active.\n       * If scrolling is active this area is getting re-dragged by the\n       * anonymize scroll function.\n       */\n      _frame.next(evt);\n    }\n\n    this._handleMoveEvent(evt);\n  }\n\n  _handleMoveEvent(evt: MouseEvent | TouchEvent) {\n    const { features } = this._options;\n\n    /**\n     * - Prevent auto-refresh for when pulling down on touch devices.\n     * - Prevent auto-scroll by the browser when on safari and scrolling is handled by viselect.\n     */\n    if (\n      (features.touch && isTouchDevice()) ||\n      (this._scrollAvailable && isSafariBrowser())\n    ) {\n      evt.preventDefault(); // Prevent swipe-down refresh\n    }\n  }\n\n  _onScroll(): void {\n    const {\n      _scrollDelta,\n      _options: { document },\n    } = this;\n    const { scrollTop, scrollLeft } =\n      document.scrollingElement || document.body;\n\n    // Adjust area start location\n    this._areaLocation.x1 += _scrollDelta.x - scrollLeft;\n    this._areaLocation.y1 += _scrollDelta.y - scrollTop;\n    _scrollDelta.x = scrollLeft;\n    _scrollDelta.y = scrollTop;\n\n    // The area needs to be set back as the target-container has changed in its position\n    this._setupSelectionArea();\n    this._frame.next(null);\n  }\n\n  _manualScroll(evt: ScrollEvent): void {\n    const { manualSpeed } = this._options.behaviour.scrolling;\n\n    // Consistent scrolling speed on all browsers\n    const deltaY = evt.deltaY ? (evt.deltaY > 0 ? 1 : -1) : 0;\n    const deltaX = evt.deltaX ? (evt.deltaX > 0 ? 1 : -1) : 0;\n    this._scrollSpeed.y += deltaY * manualSpeed;\n    this._scrollSpeed.x += deltaX * manualSpeed;\n    this._onTapMove(evt);\n\n    // Prevent default scrolling behaviour, e.g. page scrolling\n    evt.preventDefault();\n  }\n\n  _recalculateSelectionAreaRect(): void {\n    const { _scrollSpeed, _areaLocation, _areaRect, _targetElement, _options } =\n      this;\n    const {\n      scrollTop,\n      scrollHeight,\n      clientHeight,\n      scrollLeft,\n      scrollWidth,\n      clientWidth,\n    } = _targetElement as Element;\n    const _targetRect = this._targetRect as DOMRect;\n\n    const { x1, y1 } = _areaLocation;\n    let { x2, y2 } = _areaLocation;\n\n    const {\n      behaviour: {\n        scrolling: { startScrollMargins },\n      },\n    } = _options;\n\n    if (x2 < _targetRect.left + startScrollMargins.x) {\n      _scrollSpeed.x = scrollLeft\n        ? -abs(_targetRect.left - x2 + startScrollMargins.x)\n        : 0;\n      x2 = x2 < _targetRect.left ? _targetRect.left : x2;\n    } else if (x2 > _targetRect.right - startScrollMargins.x) {\n      _scrollSpeed.x =\n        scrollWidth - scrollLeft - clientWidth\n          ? abs(\n              _targetRect.left + _targetRect.width - x2 - startScrollMargins.x\n            )\n          : 0;\n      x2 = x2 > _targetRect.right ? _targetRect.right : x2;\n    } else {\n      _scrollSpeed.x = 0;\n    }\n\n    if (y2 < _targetRect.top + startScrollMargins.y) {\n      _scrollSpeed.y = scrollTop\n        ? -abs(_targetRect.top - y2 + startScrollMargins.y)\n        : 0;\n      y2 = y2 < _targetRect.top ? _targetRect.top : y2;\n    } else if (y2 > _targetRect.bottom - startScrollMargins.y) {\n      _scrollSpeed.y =\n        scrollHeight - scrollTop - clientHeight\n          ? abs(\n              _targetRect.top + _targetRect.height - y2 - startScrollMargins.y\n            )\n          : 0;\n      y2 = y2 > _targetRect.bottom ? _targetRect.bottom : y2;\n    } else {\n      _scrollSpeed.y = 0;\n    }\n\n    const x3 = min(x1, x2);\n    const y3 = min(y1, y2);\n    const x4 = max(x1, x2);\n    const y4 = max(y1, y2);\n\n    _areaRect.x = x3;\n    _areaRect.y = y3;\n    _areaRect.width = x4 - x3;\n    _areaRect.height = y4 - y3;\n  }\n\n  _redrawSelectionArea(): void {\n    const { x, y, width, height } = this._areaRect;\n    const { style } = this._area;\n\n    // Using transform will make the area's borders look blurry\n    style.left = `${x}px`;\n    style.top = `${y}px`;\n    style.width = `${width}px`;\n    style.height = `${height}px`;\n  }\n\n  _onTapStop(evt: MouseEvent | TouchEvent | null, silent: boolean): void {\n    const { document, features } = this._options;\n    const { _singleClick } = this;\n\n    // Remove event handlers\n    off(document, [\"mousemove\", \"touchmove\"], this._delayedTapMove);\n    off(document, [\"touchmove\", \"mousemove\"], this._onTapMove);\n    off(document, [\"mouseup\", \"touchcancel\", \"touchend\"], this._onTapStop);\n    off(document, \"scroll\", this._onScroll);\n\n    // Keep selection until the next time\n    this._keepSelection();\n\n    if (evt && _singleClick && features.singleTap.allow) {\n      this._onSingleTap(evt);\n    } else if (!_singleClick && !silent) {\n      this._updateElementSelection();\n      this._emitEvent(\"stop\", evt);\n    }\n\n    this._scrollSpeed.x = 0;\n    this._scrollSpeed.y = 0;\n\n    // Unbind mouse scrolling listener\n    this._scrollAvailable &&\n      off(document, \"wheel\", this._manualScroll, { passive: true });\n\n    // Remove selection-area from dom\n    this._clippingElement.remove();\n\n    // Cancel current frame\n    this._frame?.cancel();\n\n    // Hide selection area\n    css(this._area, \"display\", \"none\");\n  }\n\n  _updateElementSelection(): void {\n    const { _selectables, _options, _selection, _areaRect } = this;\n    const { stored, selected, touched } = _selection;\n    const { intersect, overlap } = _options.behaviour;\n\n    const invert = overlap === \"invert\";\n    const newlyTouched: Element[] = [];\n    const added: Element[] = [];\n    const removed: Element[] = [];\n\n    // Find newly selected elements\n    for (let i = 0; i < _selectables.length; i++) {\n      const node = _selectables[i];\n\n      // Check if area intersects element\n      if (intersects(_areaRect, node.getBoundingClientRect(), intersect)) {\n        // Check if the element wasn't present in the last selection.\n        if (!selected.includes(node)) {\n          // Check if user wants to invert the selection for already selected elements\n          if (invert && stored.includes(node)) {\n            removed.push(node);\n            continue;\n          } else {\n            added.push(node);\n          }\n        } else if (stored.includes(node) && !touched.includes(node)) {\n          touched.push(node);\n        }\n\n        newlyTouched.push(node);\n      }\n    }\n\n    // Re-select elements which were previously stored\n    if (invert) {\n      added.push(...stored.filter((v) => !selected.includes(v)));\n    }\n\n    // Check which elements where removed since last selection\n    const keep = overlap === \"keep\";\n    for (let i = 0; i < selected.length; i++) {\n      const node = selected[i];\n\n      if (\n        !newlyTouched.includes(node) &&\n        !(\n          // Check if user wants to keep previously selected elements, e.g.\n          // not make them part of the current selection as soon as they're touched.\n          (keep && stored.includes(node))\n        )\n      ) {\n        removed.push(node);\n      }\n    }\n\n    _selection.selected = newlyTouched;\n    _selection.changed = { added, removed };\n    this._latestElement = newlyTouched[newlyTouched.length - 1];\n  }\n\n  _emitEvent(\n    name: keyof SelectionEvents,\n    evt: MouseEvent | TouchEvent | null\n  ): unknown {\n    return this.emit(name, {\n      event: evt,\n      store: this._selection,\n      selection: this,\n    });\n  }\n\n  _keepSelection(): void {\n    const { _options, _selection } = this;\n    const { selected, changed, touched, stored } = _selection;\n    const addedElements = selected.filter((el) => !stored.includes(el));\n\n    switch (_options.behaviour.overlap) {\n      case \"drop\": {\n        _selection.stored = [\n          ...addedElements,\n          ...stored.filter((el) => !touched.includes(el)), // Elements not touched\n        ];\n        break;\n      }\n      case \"invert\": {\n        _selection.stored = [\n          ...addedElements,\n          ...stored.filter((el) => !changed.removed.includes(el)), // Elements not removed from selection\n        ];\n        break;\n      }\n      case \"keep\": {\n        _selection.stored = [\n          ...stored,\n          ...selected.filter((el) => !stored.includes(el)), // Newly added\n        ];\n        break;\n      }\n    }\n  }\n\n  /**\n   * Manually triggers the start of a selection\n   * @param evt A MouseEvent / TouchEvent -like object\n   * @param silent If beforestart should be fired,\n   */\n  trigger(evt: MouseEvent | TouchEvent, silent = true): void {\n    this._onTapStart(evt, silent);\n  }\n\n  /**\n   * Can be used if during a selection elements have been added.\n   * Will update everything which can be selected.\n   */\n  resolveSelectables(): void {\n    this._selectables = selectAll(\n      this._options.selectables,\n      this._options.document\n    );\n  }\n\n  /**\n   * Same as deselect, but for all elements currently selected.\n   * @param includeStored If the store should also get cleared\n   * @param quiet If move / stop events should be fired\n   */\n  clearSelection(includeStored = true, quiet = false): void {\n    const { selected, stored, changed } = this._selection;\n\n    changed.added = [];\n    changed.removed.push(...selected, ...(includeStored ? stored : []));\n\n    // Fire event\n    if (!quiet) {\n      this._emitEvent(\"move\", null);\n      this._emitEvent(\"stop\", null);\n    }\n\n    // Reset state\n    // this._latestElement = undefined;\n    this._selection = {\n      stored: includeStored ? [] : stored,\n      selected: [],\n      touched: [],\n      changed: { added: [], removed: [] },\n    };\n  }\n\n  /**\n   * @returns {Array} Selected elements\n   */\n  getSelection(): Element[] {\n    return this._selection.stored;\n  }\n\n  /**\n   * @returns {HTMLElement} The selection area element\n   */\n  getSelectionArea(): HTMLElement {\n    return this._area;\n  }\n\n  /**\n   * Cancel the current selection process.\n   * @param keepEvent {boolean} true to fire a stop event after cancel.\n   */\n  cancel(keepEvent = false): void {\n    this._onTapStop(null, !keepEvent);\n  }\n\n  /**\n   * Unbinds all events and removes the area-element.\n   */\n  destroy(): void {\n    this.cancel();\n    this.disable();\n    this._clippingElement.remove();\n    super.unbindAllListeners();\n  }\n\n  /* eslint-disable no-invalid-this */\n  disable = this._bindStartEvents.bind(this, false);\n  enable = this._bindStartEvents;\n\n  /**\n   * Adds elements to the selection\n   * @param query - CSS Query, can be an array of queries\n   * @param quiet - If this should not trigger the move event\n   */\n  select(query: SelectAllSelectors, quiet = false): Element[] {\n    const { changed, selected, stored } = this._selection;\n    const elements = selectAll(query, this._options.document).filter(\n      (el) => !selected.includes(el) && !stored.includes(el)\n    );\n\n    // Update element lists\n    stored.push(...elements);\n    selected.push(...elements);\n    changed.added.push(...elements);\n    changed.removed = [];\n\n    // We don't know which element was \"selected\" first so clear it\n    this._latestElement = undefined;\n\n    // Fire event\n    if (!quiet) {\n      this._emitEvent(\"move\", null);\n      this._emitEvent(\"stop\", null);\n    }\n\n    return elements;\n  }\n\n  /**\n   * Removes a particular element from the selection.\n   * @param query - CSS Query, can be an array of queries\n   * @param quiet - If this should not trigger the move event\n   */\n  deselect(query: SelectAllSelectors, quiet = false) {\n    const { selected, stored, changed } = this._selection;\n\n    const elements = selectAll(query, this._options.document).filter(\n      (el) => selected.includes(el) || stored.includes(el)\n    );\n\n    if (!elements.length) {\n      return;\n    }\n\n    this._selection.stored = stored.filter((el) => !elements.includes(el));\n    this._selection.selected = selected.filter((el) => !elements.includes(el));\n    this._selection.changed.added = [];\n    this._selection.changed.removed.push(\n      ...elements.filter((el) => !changed.removed.includes(el))\n    );\n\n    // We don't know which element was \"selected\" first so clear it\n    this._latestElement = undefined;\n\n    // Fire event\n    if (!quiet) {\n      this._emitEvent(\"move\", null);\n      this._emitEvent(\"stop\", null);\n    }\n  }\n}\n"],"names":["EventTarget","__publicField","event","cb","set","_a","data","ok","unitify","val","unit","css","style","attr","key","value","eventListener","method","items","events","fn","options","el","ev","on","off","simplifyEvent","evt","clientX","clientY","target","intersects","a","b","mode","bxc","byc","selectAll","selector","doc","list","nodes","i","l","item","isTouchDevice","isSafariBrowser","frames","previousArgs","frameId","lock","args","abs","max","min","ceil","SelectionArea","opt","_b","_c","_d","_e","document","selectionAreaClass","selectionContainerClass","activate","features","silent","x","y","_options","targetBoundingClientRect","startAreas","resolvedBoundaries","evtPath","scrollElement","intersect","range","e","v","right","left","top","bottom","stored","reference","preceding","following","rangeItems","container","startThreshold","x1","y1","s","_clippingElement","_targetElement","_area","tr","_scrollSpeed","_areaLocation","_frame","speedDivider","scroll","scrollTop","scrollLeft","_scrollDelta","manualSpeed","deltaY","deltaX","_areaRect","scrollHeight","clientHeight","scrollWidth","clientWidth","_targetRect","x2","y2","startScrollMargins","x3","y3","x4","y4","width","height","_singleClick","_selectables","_selection","selected","touched","overlap","invert","newlyTouched","added","removed","node","keep","name","changed","addedElements","includeStored","quiet","keepEvent","query","elements"],"mappings":"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"}