{"version":3,"file":"viselect.umd.js","sources":["../src/EventEmitter.ts","../src/utils/css.ts","../src/utils/events.ts","../src/utils/intersects.ts","../src/utils/selectAll.ts","../src/utils/constants.ts","../src/utils/frames.ts","../src/index.ts"],"sourcesContent":["\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype AnyFunction = (...args: any[]) => any;\ntype EventMap = Record<string, AnyFunction>;\n\nexport class EventTarget<Events extends EventMap> {\n    private readonly _listeners = new Map<keyof Events, Set<AnyFunction>>();\n\n    public addEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\n        const set = this._listeners.get(event) || new Set();\n        this._listeners.set(event, set);\n        set.add(cb as AnyFunction);\n        return this;\n    }\n\n    public removeEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\n        this._listeners.get(event)?.delete(cb as AnyFunction);\n        return this;\n    }\n\n    public dispatchEvent<K extends keyof Events>(event: K, ...data: Parameters<Events[K]>): unknown {\n        let ok = true;\n        for (const cb of (this._listeners.get(event) || [])) {\n            ok = (cb(...data) !== false) && ok;\n        }\n\n        return ok;\n    }\n\n    public unbindAllListeners(): void {\n        this._listeners.clear();\n    }\n\n    // Let's also support on, off and emit like node\n    /* eslint-disable no-invalid-this */\n    public on = this.addEventListener;\n    public off = this.removeEventListener;\n    public emit = this.dispatchEvent;\n}\n","const unitify = (val: string | number, unit = 'px'): string => {\n    return typeof val === 'number' ? val + unit : val;\n};\n\n/**\n * Add css to a DOM-Element or returns the current\n * value of a property.\n *\n * @param el The Element.\n * @param attr The attribute or an object which holds css key-properties.\n * @param val The value for a single attribute.\n * @returns {*}\n */\nexport function css(\n    {style}: HTMLElement,\n    attr: Partial<Record<keyof CSSStyleDeclaration, string | number>> | string,\n    val?: string | number\n): void {\n    if (typeof attr === 'object') {\n\n        for (const [key, value] of Object.entries(attr)) {\n            value !== undefined && (style[key as any] = unitify(value));\n        }\n\n    } else if (val !== undefined) {\n        style[attr as any] = unitify(val);\n    }\n}\n\n\n","/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype Method = 'addEventListener' | 'removeEventListener';\ntype AnyFunction = (...arg: any) => any;\n\nexport type EventBindingArgs = [\n        EventTarget | EventTarget[],\n        string | string[],\n    AnyFunction,\n    Record<string, unknown>?\n];\n\ninterface EventBinding {\n    (\n        elements: EventTarget | EventTarget[],\n        events: string | string[],\n        fn: AnyFunction,\n        options?: Record<string, unknown>\n    ): EventBindingArgs;\n}\n\n/* eslint-disable prefer-rest-params */\nfunction eventListener(method: Method): EventBinding {\n    return (\n        items: EventTarget | EventTarget[],\n        events: string | string[],\n        fn: AnyFunction, options = {}\n    ): EventBindingArgs => {\n\n        // Normalize array\n        if (items instanceof HTMLCollection || items instanceof NodeList) {\n            items = Array.from(items);\n        } else if (!Array.isArray(items)) {\n            items = [items];\n        }\n\n        if (!Array.isArray(events)) {\n            events = [events];\n        }\n\n        for (const el of items) {\n            for (const ev of events) {\n                el[method](ev, fn as EventListener, {capture: false, ...options});\n            }\n        }\n\n        return [items, events, fn, options];\n    };\n}\n\n/**\n * Add event(s) to element(s).\n * @param elements DOM-Elements\n * @param events Event names\n * @param fn Callback\n * @param options Optional options\n * @return Array passed arguments\n */\nexport const on = eventListener('addEventListener');\n\n/**\n * Remove event(s) from element(s).\n * @param elements DOM-Elements\n * @param events Event names\n * @param fn Callback\n * @param options Optional options\n * @return Array passed arguments\n */\nexport const off = eventListener('removeEventListener');\n\n/**\n * Simplifies a touch / mouse-event\n * @param evt\n */\nexport const simplifyEvent = (evt: any): {\n    target: HTMLElement;\n    x: number;\n    y: number;\n} => {\n    const { clientX, clientY, target } = (evt.touches && evt.touches[0] || evt);\n    return {x: clientX, y: clientY, target};\n};\n","export type Intersection = 'center' | 'cover' | 'touch'\n\n/**\n * Check if two DOM-Elements intersects each other.\n * @param a BoundingClientRect of the first element.\n * @param b BoundingClientRect of the second element.\n * @param mode Options are center, cover or touch.\n * @returns {boolean} If both elements intersects each other.\n */\nexport function intersects(a: DOMRect, b: DOMRect, mode: Intersection = 'touch'): boolean {\n    switch (mode) {\n        case 'center': {\n            const bxc = b.left + b.width / 2;\n            const byc = b.top + b.height / 2;\n\n            return bxc >= a.left &&\n                bxc <= a.right &&\n                byc >= a.top &&\n                byc <= a.bottom;\n        }\n        case 'cover': {\n            return b.left >= a.left &&\n                b.top >= a.top &&\n                b.right <= a.right &&\n                b.bottom <= a.bottom;\n        }\n        case 'touch': {\n            return a.right >= b.left &&\n                a.left <= b.right &&\n                a.bottom >= b.top &&\n                a.top <= b.bottom;\n        }\n    }\n}\n","export type SelectAllSelectors = readonly (string | Element)[] | string | Element;\n\n/**\n * Takes a selector (or array of selectors) and returns the matched nodes.\n * @param selector The selector or an Array of selectors.\n * @param doc\n * @returns {Array} Array of DOM-Nodes.\n */\nexport function selectAll(selector: SelectAllSelectors, doc: Document = document): Element[] {\n    const list = !Array.isArray(selector) ? [selector] : selector;\n    let nodes: Element[] = [];\n\n    for (let i = 0, l = list.length; i < l; i++) {\n        const item = list[i];\n\n        if (typeof item === 'string') {\n            /**\n             * We can't use the spread operator here as with large amounts of elements\n             * we'll get a \"Maximum call stack size exceeded\"-error.\n             */\n            nodes = nodes.concat(Array.from(doc.querySelectorAll(item)));\n        } else if (item instanceof Element) {\n            nodes.push(item);\n        }\n    }\n\n    return nodes;\n}\n","// Determines if the device's primary input supports touch\n// See this article: https://css-tricks.com/touch-devices-not-judged-size/\nexport const isTouchDevice = (): boolean => matchMedia('(hover: none), (pointer: coarse)').matches;\n\n// Determines if the browser is safari\nexport const isSafariBrowser = (): boolean => 'safari' in window;\n","/* eslint-disable @typescript-eslint/no-explicit-any */\ntype AnyFunction = (...args: any[]) => void;\n\nexport interface Frames<F extends AnyFunction = AnyFunction> {\n    next(...args: Parameters<F>): void;\n\n    cancel(): void;\n}\n\nexport const frames = <F extends AnyFunction>(fn: F): Frames<F> => {\n    let previousArgs: Parameters<F>;\n    let frameId = -1;\n    let lock = false;\n\n    return {\n        next(...args: Parameters<F>): void {\n            previousArgs = args;\n\n            if (!lock) {\n                lock = true;\n                frameId = requestAnimationFrame(() => {\n                    fn(...previousArgs);\n                    lock = false;\n                });\n            }\n        },\n        cancel() {\n            cancelAnimationFrame(frameId);\n            lock = false;\n        }\n    };\n};\n","import { EventTarget } from \"./EventEmitter\";\nimport type {\n  AreaLocation,\n  Coordinates,\n  ScrollEvent,\n  SelectionEvents,\n  SelectionOptions,\n  SelectionStore,\n} from \"./types\";\nimport { PartialSelectionOptions } from \"./types\";\nimport {\n  css,\n  frames,\n  Frames,\n  intersects,\n  isSafariBrowser,\n  isTouchDevice,\n  off,\n  on,\n  selectAll,\n  SelectAllSelectors,\n  simplifyEvent,\n} from \"./utils\";\n\n// Re-export types\nexport * from \"./types\";\n\n// Some var shorting for better compression and readability\nconst { abs, max, min, ceil } = Math;\n\nexport default class SelectionArea extends EventTarget<SelectionEvents> {\n  public static version = VERSION;\n\n  // Options\n  private readonly _options: SelectionOptions;\n\n  // Selection store\n  private _selection: SelectionStore = {\n    stored: [],\n    selected: [],\n    touched: [],\n    changed: {\n      added: [], // Added elements since last selection\n      removed: [], // Removed elements since last selection\n    },\n  };\n\n  // Area element and clipping element\n  private readonly _area: HTMLElement;\n  private readonly _clippingElement: HTMLElement;\n\n  // Target container (element) and boundary (cached)\n  private _targetElement?: Element;\n  private _targetRect?: DOMRect;\n  private _selectables: Element[] = [];\n  private _latestElement?: Element;\n\n  // Caches the position of the selection-area\n  private readonly _areaRect = new DOMRect();\n\n  // Dynamically constructed area rect\n  private _areaLocation: AreaLocation = { y1: 0, x2: 0, y2: 0, x1: 0 };\n\n  // If a single click is being performed.\n  // It's a single-click until the user dragged the mouse.\n  private _singleClick = true;\n  private _frame: Frames;\n\n  // Is getting set on movement.\n  private _scrollAvailable = true;\n  private _scrollingActive = false;\n  private _scrollSpeed: Coordinates = { x: 0, y: 0 };\n  private _scrollDelta: Coordinates = { x: 0, y: 0 };\n\n  constructor(opt: PartialSelectionOptions) {\n    super();\n\n    this._options = {\n      selectionAreaClass: \"selection-area\",\n      selectionContainerClass: undefined,\n      selectables: [],\n      document: window.document,\n      startAreas: [\"html\"],\n      boundaries: [\"html\"],\n      container: \"body\",\n      ...opt,\n\n      behaviour: {\n        overlap: \"invert\",\n        intersect: \"touch\",\n        ...opt.behaviour,\n        startThreshold: opt.behaviour?.startThreshold\n          ? typeof opt.behaviour.startThreshold === \"number\"\n            ? opt.behaviour.startThreshold\n            : { x: 10, y: 10, ...opt.behaviour.startThreshold }\n          : { x: 10, y: 10 },\n        scrolling: {\n          speedDivider: 10,\n          manualSpeed: 750,\n          ...opt.behaviour?.scrolling,\n          startScrollMargins: {\n            x: 0,\n            y: 0,\n            ...opt.behaviour?.scrolling?.startScrollMargins,\n          },\n        },\n      },\n\n      features: {\n        range: true,\n        touch: true,\n        ...opt.features,\n        singleTap: {\n          allow: true,\n          intersect: \"native\",\n          ...opt.features?.singleTap,\n        },\n      },\n    };\n\n    // Bind locale functions to instance\n    /* eslint-disable @typescript-eslint/no-explicit-any */\n    for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {\n      if (typeof (this as any)[key] === \"function\") {\n        (this as any)[key] = (this as any)[key].bind(this);\n      }\n    }\n\n    const { document, selectionAreaClass, selectionContainerClass } =\n      this._options;\n    this._area = document.createElement(\"div\");\n    this._clippingElement = document.createElement(\"div\");\n    this._clippingElement.appendChild(this._area);\n\n    this._area.classList.add(selectionAreaClass);\n    selectionContainerClass &&\n      this._clippingElement.classList.add(selectionContainerClass);\n\n    css(this._area, {\n      willChange: \"top, left, bottom, right, width, height\",\n      top: 0,\n      left: 0,\n      position: \"fixed\",\n    });\n\n    css(this._clippingElement, {\n      overflow: \"hidden\",\n      position: \"fixed\",\n      transform: \"translate3d(0, 0, 0)\", // https://stackoverflow.com/a/38268846\n      pointerEvents: \"none\",\n      zIndex: \"1\",\n    });\n\n    this._frame = frames((evt: MouseEvent | TouchEvent) => {\n      this._recalculateSelectionAreaRect();\n      this._updateElementSelection();\n      this._emitEvent(\"move\", evt);\n      this._redrawSelectionArea();\n    });\n\n    this.enable();\n  }\n\n  _bindStartEvents(activate = true): void {\n    const { document, features } = this._options;\n    const fn = activate ? on : off;\n\n    fn(document, \"mousedown\", this._onTapStart);\n    features.touch &&\n      fn(document, \"touchstart\", this._onTapStart, {\n        passive: false,\n      });\n  }\n\n  _onTapStart(evt: MouseEvent | TouchEvent, silent = false): void {\n    const { x, y, target } = simplifyEvent(evt);\n    const { _options } = this;\n    const { document } = this._options;\n    const targetBoundingClientRect = target.getBoundingClientRect();\n\n    // Find start-areas and boundaries\n    const startAreas = selectAll(_options.startAreas, _options.document);\n    const resolvedBoundaries = selectAll(\n      _options.boundaries,\n      _options.document\n    );\n\n    // Check in which container the user currently acts\n    this._targetElement = resolvedBoundaries.find((el) =>\n      intersects(el.getBoundingClientRect(), targetBoundingClientRect)\n    );\n\n    // Check if area starts in one of the start areas / boundaries\n    const evtPath = evt.composedPath();\n    if (\n      !this._targetElement ||\n      !startAreas.find((el) => evtPath.includes(el)) ||\n      !resolvedBoundaries.find((el) => evtPath.includes(el))\n    ) {\n      return;\n    }\n\n    if (!silent && this._emitEvent(\"beforestart\", evt) === false) {\n      return;\n    }\n\n    this._areaLocation = { x1: x, y1: y, x2: 0, y2: 0 };\n\n    // Lock scrolling in target container\n    const scrollElement = document.scrollingElement || document.body;\n    this._scrollDelta = {\n      x: scrollElement.scrollLeft,\n      y: scrollElement.scrollTop,\n    };\n\n    // To detect single-click\n    this._singleClick = true;\n    this.clearSelection(false, true);\n\n    on(document, [\"touchmove\", \"mousemove\"], this._delayedTapMove, {\n      passive: false,\n    });\n    on(document, [\"mouseup\", \"touchcancel\", \"touchend\"], this._onTapStop);\n    on(document, \"scroll\", this._onScroll);\n  }\n\n  _onSingleTap(evt: MouseEvent | TouchEvent): void {\n    const {\n      singleTap: { intersect },\n      range,\n    } = this._options.features;\n    const e = simplifyEvent(evt);\n    let target;\n\n    if (intersect === \"native\") {\n      target = e.target;\n    } else if (intersect === \"touch\") {\n      this.resolveSelectables();\n\n      const { x, y } = e;\n      target = this._selectables.find((v) => {\n        const { right, left, top, bottom } = v.getBoundingClientRect();\n        return x < right && x > left && y < bottom && y > top;\n      });\n    }\n\n    if (!target) {\n      return;\n    }\n\n    /**\n     * Resolve selectables again.\n     * If the user started in a scrollable area they will be reduced\n     * to the current area. Prevent the exclusion of these if a range-selection\n     * gets performed.\n     */\n    this.resolveSelectables();\n\n    // Traverse dom upwards to check if target is selectable\n    while (!this._selectables.includes(target)) {\n      if (!target.parentElement) {\n        return;\n      }\n\n      target = target.parentElement;\n    }\n\n    // Grab current store first in case it gets set back\n    const { stored } = this._selection;\n    this._emitEvent(\"start\", evt);\n\n    if (evt.shiftKey && stored.length && range) {\n      const reference = this._latestElement ?? stored[0];\n\n      // Resolve correct range\n      const [preceding, following] =\n        reference.compareDocumentPosition(target) & 4\n          ? [target, reference]\n          : [reference, target];\n\n      const rangeItems = [\n        ...this._selectables.filter(\n          (el) =>\n            el.compareDocumentPosition(preceding) & 4 &&\n            el.compareDocumentPosition(following) & 2\n        ),\n        preceding,\n        following,\n      ];\n\n      this.select(rangeItems);\n      this._latestElement = target;\n    } else if (\n      stored.includes(target) &&\n      (stored.length === 1 ||\n        evt.ctrlKey ||\n        stored.every((v) => this._selection.stored.includes(v)))\n    ) {\n      this.deselect(target);\n      this._latestElement = target;\n    } else {\n      this.select(target);\n      this._latestElement = target;\n    }\n\n    this._emitEvent(\"stop\", evt);\n  }\n\n  _delayedTapMove(evt: MouseEvent | TouchEvent): void {\n    const {\n      container,\n      document,\n      behaviour: { startThreshold },\n    } = this._options;\n    const { x1, y1 } = this._areaLocation; // Coordinates of first \"tap\"\n    const { x, y } = simplifyEvent(evt);\n\n    // Check pixel threshold\n    if (\n      // Single number for both coordinates\n      (typeof startThreshold === \"number\" &&\n        abs(x + y - (x1 + y1)) >= startThreshold) ||\n      // Different x and y threshold\n      (typeof startThreshold === \"object\" &&\n        abs(x - x1) >= (startThreshold as Coordinates).x) ||\n      abs(y - y1) >= (startThreshold as Coordinates).y\n    ) {\n      off(document, [\"mousemove\", \"touchmove\"], this._delayedTapMove, {\n        passive: false,\n      });\n\n      if (this._emitEvent(\"beforedrag\", evt) === false) {\n        off(document, [\"mouseup\", \"touchcancel\", \"touchend\"], this._onTapStop);\n        return;\n      }\n\n      on(document, [\"mousemove\", \"touchmove\"], this._onTapMove, {\n        passive: false,\n      });\n\n      // Make area element visible\n      css(this._area, \"display\", \"block\");\n\n      // Append selection-area to the dom\n      selectAll(container, document)[0].appendChild(this._clippingElement);\n\n      this.resolveSelectables();\n\n      // An action is recognized as single-select until the user performed a multi-selection\n      this._singleClick = false;\n\n      // Just saving the boundaries of this container for later\n      this._targetRect = this._targetElement!.getBoundingClientRect();\n\n      // Find container and check if it's scrollable\n      this._scrollAvailable =\n        this._targetElement!.scrollHeight !==\n          this._targetElement!.clientHeight ||\n        this._targetElement!.scrollWidth !== this._targetElement!.clientWidth;\n\n      if (this._scrollAvailable) {\n        // Detect mouse scrolling\n        on(document, \"wheel\", this._manualScroll, { passive: false });\n\n        /**\n         * The selection-area will also cover other element which are\n         * out of the current scrollable parent. So find all elements\n         * which are in the current scrollable element. Later these are\n         * the only selectables instead of all.\n         */\n        this._selectables = this._selectables.filter((s) =>\n          this._targetElement!.contains(s)\n        );\n      }\n\n      // Re-setup selection area and fire event\n      this._setupSelectionArea();\n      this._emitEvent(\"start\", evt);\n      this._onTapMove(evt);\n    }\n\n    this._handleMoveEvent(evt);\n  }\n\n  _setupSelectionArea(): void {\n    const { _clippingElement, _targetElement, _area } = this;\n    const tr = (this._targetRect = _targetElement!.getBoundingClientRect());\n\n    if (this._scrollAvailable) {\n      /**\n       * To clip the area, the selection area has a parent\n       * which has exact the same dimensions as the scrollable element.\n       * Now if the area exceeds these boundaries it will be cropped.\n       */\n      css(_clippingElement, {\n        top: tr.top,\n        left: tr.left,\n        width: tr.width,\n        height: tr.height,\n      });\n\n      /**\n       * The area element is relative to the clipping element,\n       * but when this is moved or transformed we need to correct\n       * the positions via a negative margin.\n       */\n      css(_area, {\n        marginTop: -tr.top,\n        marginLeft: -tr.left,\n      });\n    } else {\n      // \"Reset\" styles\n      css(_clippingElement, {\n        top: 0,\n        left: 0,\n        width: \"100%\",\n        height: \"100%\",\n      });\n\n      css(_area, {\n        marginTop: 0,\n        marginLeft: 0,\n      });\n    }\n  }\n\n  _onTapMove(evt: MouseEvent | TouchEvent): void {\n    const { x, y } = simplifyEvent(evt);\n    const { _scrollSpeed, _areaLocation, _options, _frame } = this;\n    const { speedDivider } = _options.behaviour.scrolling;\n    const _targetElement = this._targetElement as Element;\n\n    _areaLocation.x2 = x;\n    _areaLocation.y2 = y;\n\n    if (\n      this._scrollAvailable &&\n      !this._scrollingActive &&\n      (_scrollSpeed.y || _scrollSpeed.x)\n    ) {\n      // Continuous scrolling\n      this._scrollingActive = true;\n\n      const scroll = () => {\n        if (!_scrollSpeed.x && !_scrollSpeed.y) {\n          this._scrollingActive = false;\n          return;\n        }\n\n        // Reduce velocity, use ceil in both directions to scroll at least 1px per frame\n        const { scrollTop, scrollLeft } = _targetElement;\n\n        if (_scrollSpeed.y) {\n          _targetElement.scrollTop += ceil(_scrollSpeed.y / speedDivider);\n          _areaLocation.y1 -= _targetElement.scrollTop - scrollTop;\n        }\n\n        if (_scrollSpeed.x) {\n          _targetElement.scrollLeft += ceil(_scrollSpeed.x / speedDivider);\n          _areaLocation.x1 -= _targetElement.scrollLeft - scrollLeft;\n        }\n\n        /**\n         * We changed the start coordinates -> redraw the selection-area\n         * We changed the dimensions of the area element -> re-calc selected elements\n         * The selected elements array has been changed -> fire event\n         */\n        _frame.next(evt);\n\n        // Keep scrolling even if the user stops to move his pointer\n        requestAnimationFrame(scroll);\n      };\n\n      requestAnimationFrame(scroll);\n    } else {\n      /**\n       * Perform redraw only if scrolling is not active.\n       * If scrolling is active this area is getting re-dragged by the\n       * anonymize scroll function.\n       */\n      _frame.next(evt);\n    }\n\n    this._handleMoveEvent(evt);\n  }\n\n  _handleMoveEvent(evt: MouseEvent | TouchEvent) {\n    const { features } = this._options;\n\n    /**\n     * - Prevent auto-refresh for when pulling down on touch devices.\n     * - Prevent auto-scroll by the browser when on safari and scrolling is handled by viselect.\n     */\n    if (\n      (features.touch && isTouchDevice()) ||\n      (this._scrollAvailable && isSafariBrowser())\n    ) {\n      evt.preventDefault(); // Prevent swipe-down refresh\n    }\n  }\n\n  _onScroll(): void {\n    const {\n      _scrollDelta,\n      _options: { document },\n    } = this;\n    const { scrollTop, scrollLeft } =\n      document.scrollingElement || document.body;\n\n    // Adjust area start location\n    this._areaLocation.x1 += _scrollDelta.x - scrollLeft;\n    this._areaLocation.y1 += _scrollDelta.y - scrollTop;\n    _scrollDelta.x = scrollLeft;\n    _scrollDelta.y = scrollTop;\n\n    // The area needs to be set back as the target-container has changed in its position\n    this._setupSelectionArea();\n    this._frame.next(null);\n  }\n\n  _manualScroll(evt: ScrollEvent): void {\n    const { manualSpeed } = this._options.behaviour.scrolling;\n\n    // Consistent scrolling speed on all browsers\n    const deltaY = evt.deltaY ? (evt.deltaY > 0 ? 1 : -1) : 0;\n    const deltaX = evt.deltaX ? (evt.deltaX > 0 ? 1 : -1) : 0;\n    this._scrollSpeed.y += deltaY * manualSpeed;\n    this._scrollSpeed.x += deltaX * manualSpeed;\n    this._onTapMove(evt);\n\n    // Prevent default scrolling behaviour, e.g. page scrolling\n    evt.preventDefault();\n  }\n\n  _recalculateSelectionAreaRect(): void {\n    const { _scrollSpeed, _areaLocation, _areaRect, _targetElement, _options } =\n      this;\n    const {\n      scrollTop,\n      scrollHeight,\n      clientHeight,\n      scrollLeft,\n      scrollWidth,\n      clientWidth,\n    } = _targetElement as Element;\n    const _targetRect = this._targetRect as DOMRect;\n\n    const { x1, y1 } = _areaLocation;\n    let { x2, y2 } = _areaLocation;\n\n    const {\n      behaviour: {\n        scrolling: { startScrollMargins },\n      },\n    } = _options;\n\n    if (x2 < _targetRect.left + startScrollMargins.x) {\n      _scrollSpeed.x = scrollLeft\n        ? -abs(_targetRect.left - x2 + startScrollMargins.x)\n        : 0;\n      x2 = x2 < _targetRect.left ? _targetRect.left : x2;\n    } else if (x2 > _targetRect.right - startScrollMargins.x) {\n      _scrollSpeed.x =\n        scrollWidth - scrollLeft - clientWidth\n          ? abs(\n              _targetRect.left + _targetRect.width - x2 - startScrollMargins.x\n            )\n          : 0;\n      x2 = x2 > _targetRect.right ? _targetRect.right : x2;\n    } else {\n      _scrollSpeed.x = 0;\n    }\n\n    if (y2 < _targetRect.top + startScrollMargins.y) {\n      _scrollSpeed.y = scrollTop\n        ? -abs(_targetRect.top - y2 + startScrollMargins.y)\n        : 0;\n      y2 = y2 < _targetRect.top ? _targetRect.top : y2;\n    } else if (y2 > _targetRect.bottom - startScrollMargins.y) {\n      _scrollSpeed.y =\n        scrollHeight - scrollTop - clientHeight\n          ? abs(\n              _targetRect.top + _targetRect.height - y2 - startScrollMargins.y\n            )\n          : 0;\n      y2 = y2 > _targetRect.bottom ? _targetRect.bottom : y2;\n    } else {\n      _scrollSpeed.y = 0;\n    }\n\n    const x3 = min(x1, x2);\n    const y3 = min(y1, y2);\n    const x4 = max(x1, x2);\n    const y4 = max(y1, y2);\n\n    _areaRect.x = x3;\n    _areaRect.y = y3;\n    _areaRect.width = x4 - x3;\n    _areaRect.height = y4 - y3;\n  }\n\n  _redrawSelectionArea(): void {\n    const { x, y, width, height } = this._areaRect;\n    const { style } = this._area;\n\n    // Using transform will make the area's borders look blurry\n    style.left = `${x}px`;\n    style.top = `${y}px`;\n    style.width = `${width}px`;\n    style.height = `${height}px`;\n  }\n\n  _onTapStop(evt: MouseEvent | TouchEvent | null, silent: boolean): void {\n    const { document, features } = this._options;\n    const { _singleClick } = this;\n\n    // Remove event handlers\n    off(document, [\"mousemove\", \"touchmove\"], this._delayedTapMove);\n    off(document, [\"touchmove\", \"mousemove\"], this._onTapMove);\n    off(document, [\"mouseup\", \"touchcancel\", \"touchend\"], this._onTapStop);\n    off(document, \"scroll\", this._onScroll);\n\n    // Keep selection until the next time\n    this._keepSelection();\n\n    if (evt && _singleClick && features.singleTap.allow) {\n      this._onSingleTap(evt);\n    } else if (!_singleClick && !silent) {\n      this._updateElementSelection();\n      this._emitEvent(\"stop\", evt);\n    }\n\n    this._scrollSpeed.x = 0;\n    this._scrollSpeed.y = 0;\n\n    // Unbind mouse scrolling listener\n    this._scrollAvailable &&\n      off(document, \"wheel\", this._manualScroll, { passive: true });\n\n    // Remove selection-area from dom\n    this._clippingElement.remove();\n\n    // Cancel current frame\n    this._frame?.cancel();\n\n    // Hide selection area\n    css(this._area, \"display\", \"none\");\n  }\n\n  _updateElementSelection(): void {\n    const { _selectables, _options, _selection, _areaRect } = this;\n    const { stored, selected, touched } = _selection;\n    const { intersect, overlap } = _options.behaviour;\n\n    const invert = overlap === \"invert\";\n    const newlyTouched: Element[] = [];\n    const added: Element[] = [];\n    const removed: Element[] = [];\n\n    // Find newly selected elements\n    for (let i = 0; i < _selectables.length; i++) {\n      const node = _selectables[i];\n\n      // Check if area intersects element\n      if (intersects(_areaRect, node.getBoundingClientRect(), intersect)) {\n        // Check if the element wasn't present in the last selection.\n        if (!selected.includes(node)) {\n          // Check if user wants to invert the selection for already selected elements\n          if (invert && stored.includes(node)) {\n            removed.push(node);\n            continue;\n          } else {\n            added.push(node);\n          }\n        } else if (stored.includes(node) && !touched.includes(node)) {\n          touched.push(node);\n        }\n\n        newlyTouched.push(node);\n      }\n    }\n\n    // Re-select elements which were previously stored\n    if (invert) {\n      added.push(...stored.filter((v) => !selected.includes(v)));\n    }\n\n    // Check which elements where removed since last selection\n    const keep = overlap === \"keep\";\n    for (let i = 0; i < selected.length; i++) {\n      const node = selected[i];\n\n      if (\n        !newlyTouched.includes(node) &&\n        !(\n          // Check if user wants to keep previously selected elements, e.g.\n          // not make them part of the current selection as soon as they're touched.\n          (keep && stored.includes(node))\n        )\n      ) {\n        removed.push(node);\n      }\n    }\n\n    _selection.selected = newlyTouched;\n    _selection.changed = { added, removed };\n    this._latestElement = newlyTouched[newlyTouched.length - 1];\n  }\n\n  _emitEvent(\n    name: keyof SelectionEvents,\n    evt: MouseEvent | TouchEvent | null\n  ): unknown {\n    return this.emit(name, {\n      event: evt,\n      store: this._selection,\n      selection: this,\n    });\n  }\n\n  _keepSelection(): void {\n    const { _options, _selection } = this;\n    const { selected, changed, touched, stored } = _selection;\n    const addedElements = selected.filter((el) => !stored.includes(el));\n\n    switch (_options.behaviour.overlap) {\n      case \"drop\": {\n        _selection.stored = [\n          ...addedElements,\n          ...stored.filter((el) => !touched.includes(el)), // Elements not touched\n        ];\n        break;\n      }\n      case \"invert\": {\n        _selection.stored = [\n          ...addedElements,\n          ...stored.filter((el) => !changed.removed.includes(el)), // Elements not removed from selection\n        ];\n        break;\n      }\n      case \"keep\": {\n        _selection.stored = [\n          ...stored,\n          ...selected.filter((el) => !stored.includes(el)), // Newly added\n        ];\n        break;\n      }\n    }\n  }\n\n  /**\n   * Manually triggers the start of a selection\n   * @param evt A MouseEvent / TouchEvent -like object\n   * @param silent If beforestart should be fired,\n   */\n  trigger(evt: MouseEvent | TouchEvent, silent = true): void {\n    this._onTapStart(evt, silent);\n  }\n\n  /**\n   * Can be used if during a selection elements have been added.\n   * Will update everything which can be selected.\n   */\n  resolveSelectables(): void {\n    this._selectables = selectAll(\n      this._options.selectables,\n      this._options.document\n    );\n  }\n\n  /**\n   * Same as deselect, but for all elements currently selected.\n   * @param includeStored If the store should also get cleared\n   * @param quiet If move / stop events should be fired\n   */\n  clearSelection(includeStored = true, quiet = false): void {\n    const { selected, stored, changed } = this._selection;\n\n    changed.added = [];\n    changed.removed.push(...selected, ...(includeStored ? stored : []));\n\n    // Fire event\n    if (!quiet) {\n      this._emitEvent(\"move\", null);\n      this._emitEvent(\"stop\", null);\n    }\n\n    // Reset state\n    // this._latestElement = undefined;\n    this._selection = {\n      stored: includeStored ? [] : stored,\n      selected: [],\n      touched: [],\n      changed: { added: [], removed: [] },\n    };\n  }\n\n  /**\n   * @returns {Array} Selected elements\n   */\n  getSelection(): Element[] {\n    return this._selection.stored;\n  }\n\n  /**\n   * @returns {HTMLElement} The selection area element\n   */\n  getSelectionArea(): HTMLElement {\n    return this._area;\n  }\n\n  /**\n   * Cancel the current selection process.\n   * @param keepEvent {boolean} true to fire a stop event after cancel.\n   */\n  cancel(keepEvent = false): void {\n    this._onTapStop(null, !keepEvent);\n  }\n\n  /**\n   * Unbinds all events and removes the area-element.\n   */\n  destroy(): void {\n    this.cancel();\n    this.disable();\n    this._clippingElement.remove();\n    super.unbindAllListeners();\n  }\n\n  /* eslint-disable no-invalid-this */\n  disable = this._bindStartEvents.bind(this, false);\n  enable = this._bindStartEvents;\n\n  /**\n   * Adds elements to the selection\n   * @param query - CSS Query, can be an array of queries\n   * @param quiet - If this should not trigger the move event\n   */\n  select(query: SelectAllSelectors, quiet = false): Element[] {\n    const { changed, selected, stored } = this._selection;\n    const elements = selectAll(query, this._options.document).filter(\n      (el) => !selected.includes(el) && !stored.includes(el)\n    );\n\n    // Update element lists\n    stored.push(...elements);\n    selected.push(...elements);\n    changed.added.push(...elements);\n    changed.removed = [];\n\n    // We don't know which element was \"selected\" first so clear it\n    this._latestElement = undefined;\n\n    // Fire event\n    if (!quiet) {\n      this._emitEvent(\"move\", null);\n      this._emitEvent(\"stop\", null);\n    }\n\n    return elements;\n  }\n\n  /**\n   * Removes a particular element from the selection.\n   * @param query - CSS Query, can be an array of queries\n   * @param quiet - If this should not trigger the move event\n   */\n  deselect(query: SelectAllSelectors, quiet = false) {\n    const { selected, stored, changed } = this._selection;\n\n    const elements = selectAll(query, this._options.document).filter(\n      (el) => selected.includes(el) || stored.includes(el)\n    );\n\n    if (!elements.length) {\n      return;\n    }\n\n    this._selection.stored = stored.filter((el) => !elements.includes(el));\n    this._selection.selected = selected.filter((el) => !elements.includes(el));\n    this._selection.changed.added = [];\n    this._selection.changed.removed.push(\n      ...elements.filter((el) => !changed.removed.includes(el))\n    );\n\n    // We don't know which element was \"selected\" first so clear it\n    this._latestElement = undefined;\n\n    // Fire event\n    if (!quiet) {\n      this._emitEvent(\"move\", null);\n      this._emitEvent(\"stop\", null);\n    }\n  }\n}\n"],"names":["EventTarget","__publicField","event","cb","set","_a","data","ok","unitify","val","unit","css","style","attr","key","value","eventListener","method","items","events","fn","options","el","ev","on","off","simplifyEvent","evt","clientX","clientY","target","intersects","a","b","mode","bxc","byc","selectAll","selector","doc","list","nodes","i","l","item","isTouchDevice","isSafariBrowser","frames","previousArgs","frameId","lock","args","abs","max","min","ceil","SelectionArea","opt","_b","_d","_c","_e","document","selectionAreaClass","selectionContainerClass","activate","features","silent","x","y","_options","targetBoundingClientRect","startAreas","resolvedBoundaries","evtPath","scrollElement","intersect","range","e","v","right","left","top","bottom","stored","reference","preceding","following","rangeItems","container","startThreshold","x1","y1","s","_clippingElement","_targetElement","_area","tr","_scrollSpeed","_areaLocation","_frame","speedDivider","scroll","scrollTop","scrollLeft","_scrollDelta","manualSpeed","deltaY","deltaX","_areaRect","scrollHeight","clientHeight","scrollWidth","clientWidth","_targetRect","x2","y2","startScrollMargins","x3","y3","x4","y4","width","height","_singleClick","_selectables","_selection","selected","touched","overlap","invert","newlyTouched","added","removed","node","keep","name","changed","addedElements","includeStored","quiet","keepEvent","query","elements"],"mappings":"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"}